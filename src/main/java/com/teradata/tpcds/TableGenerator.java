/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.teradata.tpcds;

import com.teradata.tpcds.Parallel.ChunkBoundaries;
import com.teradata.tpcds.random.RandomNumberStream;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static com.teradata.tpcds.Parallel.splitWork;
import static com.teradata.tpcds.random.RandomValueGenerator.generateUniformRandomInt;
import static com.teradata.tpcds.type.Date.JULIAN_DATA_START_DATE;
import static java.lang.String.format;
import static java.util.Objects.requireNonNull;

public class TableGenerator
{
    private final Session session;

    public TableGenerator(Session session)
    {
        this.session = requireNonNull(session, "session is null");
    }

    public void generateTable(Table table, long startingRowNumber, long rowCount)
    {
        // If this is a child table, and not being generated by itself, then it will get generated as part of the parent table generation.
        if (table.isChild() && !session.hasTable()) {
            return;
        }

        List<FileWriter> fileWriters = new ArrayList<>();
        try {
            addFileWritersForTableAndChildren(fileWriters, table);
            RowGenerator rowGenerator = table.getRowGenerator();
            long rowNumber = startingRowNumber;
            while (rowNumber <= rowCount) {
                RowGeneratorResult result = rowGenerator.generateRowAndChildRows(rowNumber, session);
                List<TableRow> parentAndChildRows = result.getRowAndChildRows();
                for (int i = 0; i < parentAndChildRows.size(); i++) {
                    fileWriters.get(i).write(formatRow(parentAndChildRows.get(i).getValues()));
                }

                if (result.shouldEndRow()) {
                    rowStop(table);
                    rowNumber++;
                }
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        finally {
            for (FileWriter fileWriter : fileWriters) {
                try {
                    fileWriter.close();
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private void addFileWritersForTableAndChildren(List<FileWriter> fileWriters, Table table)
            throws IOException
    {
        FileWriter fileWriter = new FileWriter(getPath(table), true);
        fileWriters.add(fileWriter);
        if (table.hasChild() && !session.hasTable()) {
            addFileWritersForTableAndChildren(fileWriters, table.getChild());
        }
    }

    private String getPath(Table table)
    {
        // TODO: path names for update and parallel cases
        return format("%s%s%s%s",
                session.getTargetDirectory(),
                File.separator,
                table.toString(),
                session.getSuffix());
    }

    private String formatRow(List<String> values)
    {
        // replace nulls with the string representation for null
        values = values.stream().map(value -> value != null ? value : session.getNullString()).collect(Collectors.toList());

        StringBuilder stringBuilder = new StringBuilder();
        char separator = session.getSeparator();
        stringBuilder.append(values.get(0));
        for (int i = 1; i < values.size(); i++) {
            stringBuilder.append(separator);
            stringBuilder.append(values.get(i));
        }
        if (session.terminateRowsWithSeparator()) {
            stringBuilder.append(separator);
        }
        stringBuilder.append('\n');
        return stringBuilder.toString();
    }

    private void rowStop(Table table)
    {
        consumeRemainingSeedsForRow(table);
        if (table.hasChild() && !session.hasTable()) {
            rowStop(table.getChild());
        }
        else if (session.hasTable() && table.isChild()) {
            rowStop(table.getParent());
        }
    }

    private void consumeRemainingSeedsForRow(Table table)
    {
        for (Column column : table.getColumns()) {
            RandomNumberStream randomNumberStream = column.getRandomNumberStream();
            while (randomNumberStream.getSeedsUsed() < randomNumberStream.getSeedsPerRow()) {
                generateUniformRandomInt(1, 100, randomNumberStream);
            }
            randomNumberStream.resetSeedsUsed();
        }
    }

    public static DateNextIndexPair skipDaysUntilFirstRowOfChunk(Table table, Session session)
    {
        // set initial conditions
        long julianDate = JULIAN_DATA_START_DATE;
        Scaling scaling = session.getScaling();
        int index = 1;
        long newDateIndex = scaling.getRowCountForDate(table, julianDate) + index;

        // move forward one day at a time
        ChunkBoundaries boundary = splitWork(table, session);
        while (index < boundary.getFirstRow()) {
            index += scaling.getRowCountForDate(table, julianDate);
            julianDate += 1;
            newDateIndex = index;
        }
        if (index > boundary.getFirstRow()) {
            julianDate -= 1;
        }

        return new DateNextIndexPair(julianDate, newDateIndex);
    }

    public static final class DateNextIndexPair
    {
        private final long julianDate;
        private final long nextDateIndex;

        public DateNextIndexPair(long julianDate, long nextDateIndex)
        {
            this.julianDate = julianDate;
            this.nextDateIndex = nextDateIndex;
        }

        public long getJulianDate()
        {
            return julianDate;
        }

        public long getNextDateIndex()
        {
            return nextDateIndex;
        }
    }
}
